# programmers_page
Lending page for Almira Polyanskaya

Ответы на вопросы
1.	Способы подключения CSS-стилей: 
•	Для придания элементу индивидуального стиля, в тег встраивается атрибут style. Ему присваивается название свойства (что именно менять) и значение этого свойства (как это менять).
•	С помощью тега <style>.  В этом случае свойства CSS описываются внутри элемента <head></head> создаётся элемент style. Пространство между тегами <style></ style> — это зона языка CSS.
•	Через отдельный файл. В этом случае файлы с расширением .html хранят html-код, а файлы с расширением .css — код на CSS. Когда стили выносят в отдельный CSS-файл, html-страница связывается с ним тегом <link>.
•	Импорт CSS: этот вариант тоже требует подключения внешнего файла стилей. Отличие в том, что этот файл содержит не весь CSS-код разом, а стили разбиты на отдельные файлы и подключаются с помощью директивы @import.  Делается ссылка на CSS-файл через тег <link>:  <link rel="stylesheet" href="main.css">. Затем в main.css импортируем несколько других CSS-файлов, header.css для шапки сайта, navbar.css для меню, и так далее: 
@import url("header.css");
@import url("navbar.css");
@import url("footer.css");
@import url("grid.css"); 
Старые веб-браузеры не будут поддерживать правило @import url. На этой особенности основывается один из хаков в CSS для скрытия неподдерживаемых стилей от старых браузеров. С точки зрения скорости работы страницы директиву @import для загрузки файла стилей вообще лучше не использовать, так как в этом случае отключается одновременная загрузка таблиц стилей. 
2.	Normalize.css — это небольшой CSS-файл, который обеспечивает для HTML-элементов лучшую кроссбраузерность (поддержку разных браузеров) в стилях по умолчанию. Цели normalize.css:
•	сохранять полезные настройки браузера, а не стирать их
•	нормализовать стили для широкого круга HTML-элементов
•	корректировать ошибки и основные несоответствия браузера
•	совершенствовать юзабилити незаметными улучшениями
•	объяснять код, используя комментарии и детальную документацию
Файл normalize.css удобен тем, что его можно не использовать целиком, — он разделён на блоки. Стили текста собраны в одну группу, стили форм — в другую. Можно удалить стили для элементов, которых нет и не будет в проекте, и сайт будет загружаться быстрее.
Необходимо подключать normalize.css в коде выше собственных стилей, иначе они «перекроют» ваши.
3.	CSS-директивы — это конструкции, которые позволяют создавать в CSS инструкции для изменения отображения либо поведения элементов страницы. Директива начинается со знака @, за которым следует одно из служебных слов. Примеры директив: 
•	@charset (эта директива определяет кодировку, используемую браузером), 
•	@import (эта директива сообщает таблице стилей о необходимости запросить и включить в себя внешний CSS-файл, причём содержимое этого файла будет добавлено непосредственно в то место, где находится @import), 
•	@namespace (эта директива особенно полезна для применения CSS к XML HTML (XHTML), с его помощью XHTML-элементы могут быть использованы как CSS-селекторы), 
•	@document (эта директива определяет условия для стилей, которые применяются к конкретной странице; например, можно задать URL страницы и затем настроить стили именно для неё; на других страницах эти стили будут проигнорированы), 
•	@font-face (эта директива позволяет загружать пользовательские шрифты для использования на странице), 
•	@keyframes (эта директива является базовым для создания покадровой анимации, позволяя задавать начальные, конечные и промежуточные шаги CSS-анимации), 
•	@media (в этой директиве находятся условные выражения, применяющие определённые стили в зависимости от характеристик экрана; эти выражения могут содержать, например, размеры экрана, что может пригодиться для создания адаптивных стилей для различных устройств), 
•	@page (эта директива определяет стили для отдельных страниц при выводе на печать; например, она содержит специальные псевдоэлементы для обращения к первой (:first), а также к левой (:left) и правой (:right) страницам при печати двух страниц на листе), 
•	@supports (эта директива определяет поддерживает ли браузер те или иные возможности, и, если поддерживает, применяет к элементам заданные стили).
4.	Отличие margin и padding: свойство padding создает свободное пространство между границей и содержимым внутри элемента, а свойство margin – это пространство вокруг границы элемента снаружи.
5.	Когда в разных CSS-правилах есть одинаковые свойства с разными значениями, то они конфликтуют между собой. Тогда требуется определить приоритетность. У селекторов существуют приоритеты. Условно можно расставить селекторы в следующем порядке по приоритету:
1)	Селектор по идентификатору
2)	Селектор по классу
3)	Селектор по тегу
где 1 — самый высокий приоритет, а 3 — самый низкий.
По этим правилам можно понять, что свойство, указанное в селекторе по идентификатору, будет обладать большим приоритетом, чем стили у селектора по тегу и классу. Это легко запомнить, если селекторы небольшие, но они могут быть сложнее. В качестве селектора может быть комбинация классов, тегов и так далее. 
В сложных селекторах считается количество вхождений тех или иных селекторов и считается суммарный вес.
Для определения приоритета можно использовать следующие правила, где каждому селектору задаётся его «вес»:
•	Селектор по тегу (типу элемента и псевдо-элемента): 1
•	Селектор по классу (псевдоклассу, селектору атрибута): 10
•	Селектор по ID: 100
•	Стиль в атрибуте тега: 1000
Чтобы узнать, какой селектор будет иметь больший вес (значение специфичности), нужно сложить все полученные значения. 
Например, нам нужно определить, какой из селекторов является приоритетным: #link .main или span #login. Селектор #link .main имеет вес 100 + 10 = 110, а селектор span #login имеет вес 1 + 100 = 101. Это означает, что селектор #link .main приоритетнее.
6.	CSS3 является новейшим стандартом для языка CSS, который разрабатывается с 2005 года. Он обратно совместим со старыми версиями CSS, что имеет новые свойства, которые отлаживают предыдущие особенности и расширяют возможности CSS2, и даже имеет некоторые JavaScript-подобные возможности. CSS3 также решает ряд проблем, связанных с разработкой мобильных приложений, учитывая адаптивный дизайн и устраняя проблемы, вызванные несовместимостью Adobe Flash на мобильных устройствах. В сочетании с JavaScript, CSS3 обладает множеством функциональных возможностей Flash, это с точки зрения анимации и интерактивности.
7 основных отличий CSS3 от CSS:
•	Мобильный первый менталитет: CSS3 поддерживает адаптивный дизайн и оснащен для обработки медиа-запросов. Медиа-запросы — это вызовы, выполняемые кодом для определения устройства и размера экрана на котором пользователь просматривает сайт. 
•	Модульный код: одним из самых важных достижений является то, что CSS3 разделен на модули. Все старые спецификации CSS были перенесены в новую версию и разделены на более мелкие части, где также добавлены некоторые новые модули.

Другие модули CSS3 включают в себя:
- Селекторы: разработчики могут редактировать элементы по имени, классу, типу, атрибуту и так далее
- Модуль Box Model: описывает подход к созданию согласованности между HTML-элементами на странице или блоками. Применяя поля границы и отступы к содержимому блока, разработчики могут очистить область вокруг элемента, присвоить ему границы
- Фоновые изображения и границы, где CSS3 также позволяет лучше контролировать обработку границ элементов и фонов страниц, а также позволяет использовать закругленные углы для прямоугольников и теней. 
- Текстовые эффекты: CSS3 включает в себя эффекты тени, переполнение текста, которое скрывает текст и становится слишком длинным для его элемента, разрыв слова, где автоматическое разбиение текста, чтобы он помещался в рамку, и перенос текста.
•	Поддержка веб-шрифтов: до CSS3 дизайнеры могли использовать только безопасные для сети шрифты (для одинакового отображения на разных компьютерах). 
Дизайнеры теперь могут запускать веб-шрифты в CSS3, специальные шрифты, подобные тем которые доступны через Google Fonts и Typecast. Эти шрифты можно либо загрузить на сервер и запустить с помощью кода CSS, либо получить доступ непосредственно из его источника с помощью сценария, который вызывается прямо в коде CSS.
•	Позволяет быстрее разрабатывать и быстрее загружать: то, что раньше требовалось для фоновых изображений, теперь CSS3 может быть достигнуто с помощью визуальных улучшений, что экономит время разработчиков на производстве. Это сокращает количество вызовов и время загрузки для множества изображений, поскольку все эти эффекты встроены в код. Кроме того, страницы загружаются быстрее благодаря общему меньшему размеру файла и меньшему количеству вызовов.
•	Создание 2D и 3D преобразований, анимации и переходов: эти эффекты позволяют элементам на странице вращаться, увеличиваться, уменьшаться, переворачиваться или переводиться в другой цвет. Впервые элементы, созданные в CSS могут перемещаться по экрану без использования JavaScript или Flash-кода.
•	Новые цвета и эффекты изображения: CSS3 поддерживает новые цвета (RGBA, HSL, HSLA) и цвета градиента, а также позволяет корректировать непрозрачность. Еще одна важная вещь — это поддержка закругленных углов изображения.
•	Исправление проблем с выравниванием: размер коробки позволяет разработчикам правильно подобрать размеры элементов без необходимости вычитать размеры для отступов и границ. Благодаря свойству box-sizing, отступ и граница включены в высоту и ширину.
7.	Псевдокласс — это селектор, который выбирает элементы, находящиеся в специфическом состоянии, например, они являются первым элементом своего типа, или на них наведён указатель мыши. Они обычно действуют так, как если бы вы применили класс к какой-то части вашего документа, что часто помогает сократить избыточные классы в разметке и даёт более гибкий, удобный в поддержке код. Браузер определяет псевдоклассы, исходя из своих знаний: об HTML-разметке: типе элементов, порядке их расположения, вложенности, языке; о действиях пользователя: кликах по ссылкам, заполнении форм, перемещении элемента мышкой.
Псевдоклассы — это ключевые слова, которые начинаются с двоеточия :pseudo-class-name, например, :first-child, :last-child, :only-child.
Псевдоэлементы ведут себя сходным образом, однако они действуют так, как если бы вы добавили в разметку целый новый HTML-элемент, а не применили класс к существующим элементам. Псевдоэлементы начинаются с двойного двоеточия, например, ::pseudo-element-name.
Эти селекторы можно комбинировать.
8.	Список тегов, которые нежелательно использовать (на основании статьи https://msiter.ru/tutorials/html-srednego-urovnya/plokhie-tegi): теги-пустышки (<font>, <blink>, <b>, <i>, <big>, <small>, <hr>), теги-вредители (<u>, <center>, <layer>, <blink>, <marquee>, <font>), плохие атрибуты (text, bgcolor, background, link, alink, vlink, align, target). Также нежелательными являются использования таблиц для html-верстки страниц и использование фреймов. Правила для создания кода: 
•	Если тег или атрибут хотя бы намекает на визуальное представление, не используйте его. Это работа CSS. И делает он ее гораздо лучше.
•	Используйте теги только для того, для чего они предназначены. Таблицы для табличных данных. Заголовки для заголовков. И так далее, и так далее.
•	Когда у вас появляется специфичный контент, используйте соответствующие теги.
9.	Один из вариантов подключения шрифтов – локальный, осуществляется в два этапа: декларация шрифта (указание на то, где брать шрифт и что с ним делать) и применения шрифта к элементу. Необходимо проделать следующее: найти и скачать или создать файлы шрифтов (в разных форматах, для кросс-браузерности). Поместить все шрифты в специальную папку, например, /site/assets/fonts. Далее нужно создать в css-файле столько директив @font-face, сколько файлов шрифтов у вас задействуется, например: 

@font-face {
src: url(/site/assets/fonts/st-Regular.ttf) format('ttf’);
font-family: 'NameofFont';
font-weight: 400;
}

@font-face {
src: url(/site/assets/fonts/st-Regular.ttf) format('ttf’);
font-family: 'NameofFont';
font-style: italic;
font-weight: 400;
}

@font-face {
 src: url(/site/assets/fonts/st-Regular.ttf) format('ttf’);
 font-family: 'NameofFont';
 font-weight: 700;
}

После этого применить в стилях нужных элементов свойство font-family, указав информацию на случай неподгружения файлов шрифта, например:

h2{
font-family: ‘NameofFont’, ‘Arial’, sans-serif;
font-weight: bold;
}

10.	Почему не стоит использовать сокращенную запись без необходимости? И если все же использовать, как это делать правильно? Некоторые свойства CSS допускают использование комбинированных свойств, что устраняет необходимость в некоторых индивидуальных свойствах. Это называется сокращенная форма записи свойств CSS. Основные свойства, которые обладают сокращённой формой записи: background, margin, padding, border, font. Применение сокращенной записи сокращает объём кода и повышает его читабельность, но с другой стороны иногда добавляет путаницу.  Проблемы использования сокращенной записи связаны с возможной отменой некоторых значений ранее указанных свойств вследствие дальнейшего использования неполной сокращенной записи, например, имеются значения отступов.

h1 {
margin-top: 50px;
margin: 0;
}

В последнем свойстве указано одно значение, и для короткой записи это будет означать margin: 0, 0, 0, 0;, поэтому к элементу применится именно margin: 0, 0, 0, 0;, отменяя первое значение свойства margin-top: 50px;.
Чтобы избежать подобных проблем, следует, во-первых, группировать свойства по смыслу (это позволит быстрее находить ошибки), а во-вторых, если требуется переопределить значения ранее заданных свойств, не стоит использовать сокращённую запись.

11.	Анимация через CSS. Свойство animation призвано сделать верстку более динамичной, оживить её для лучшего взаимодействия с пользователем. CSS-анимации позволяют анимировать переходы от одной конфигурации CSS стилей к другой. CSS-анимации состоят из двух компонентов: стилевое описание анимации и набор ключевых кадров, определяющих начальное, конечное и, возможно, промежуточное состояние анимируемых стилей. Делается это с помощью двух свойств: @keyframes (задает внешний вид анимации); animation (задает как должна протекать анимация, то есть ее продолжительность, ускорений и так далее). 
Правило @keyframes позволяет создавать анимацию с помощью набора ключевых кадров, то есть описывает состояние объекта в определенный момент времени. Запись следующая: @keyframes имя анимации {список правил}. Кадры определяют, какие свойства на каком шаге будут анимированы. Каждый кадр может включать один или более блоков объявления из одного или более пар свойств и значений.  Период задается с помощью процентов - 0% означает начало анимации, а 100% её конец. Для этого используют специальные слова: from и to. Промежуточные периоды устанавливаются только в процентах. Также можно комбинировать ключевые слова и процентные пункты. Если кадры имеют одинаковые свойства и значения, их можно объединить в одно объявление. 
После объявления правила @keyframes на него можно ссылаться в свойстве animation, которое прописывается  в стилях самого элемента для анимации.
Существует 9 свойств, которые позволяют контролировать CSS animations, они задаются также в стилях элемента, которому необходима анимация:
•	Animation-name
•	Animation-duration
•	Animation-timing-function
•	Animation-delay
•	Animation-iteration-count
•	Animation-direction
•	Animation-play-state
•	Animation-fill-mode
•	Animation



